/* eslint-disable no-return-await */
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');

exports.ifMailExist = async (req, Model) =>
  await Model.findOne({ email: req.body.email });
exports.comparePassword = (req, data) => {
  bcrypt.compare(req.body.password, data.password);
};
exports.hashPassword = async (req) => {
  await bcrypt.hash(req.body.password, await bcrypt.genSalt(10));
};
exports.createToken = (data) =>
  jwt.sign({ data }, process.env.SECRET_TOKEN, {
    expiresIn: process.env.JWT_EXPIRATION_TIME,
  });

exports.login = async (req, res, Model, validation = null) => {
  if (validation) {
    const { error } = validation(req.body);
    if (error) return res.status(400).json(error.details[0].message);
  }
  try {
    const currentUser = await this.ifMailExist(req, Model);
    const comparePassword = this.comparePassword(req, currentUser);
    if (!currentUser || !comparePassword)
      return res.status(400).json('mail or password incorrect');
    const token = this.createToken({
      id: currentUser._id,
      role: currentUser.role,
    });
    return res
      .status(200)
      .cookie('logToken', token, {
        httpOnly: true,
        maxAge: process.env.JWT_EXPIRATION_TIME,
      })
      .json({ role: currentUser.role, isAuthenticated: true });
  } catch (error) {
    res.status(500).json(error);
  }
};

exports.register = async (req, res, Model, validation = null) => {
  if (validation) {
    const { error } = validation(req.body);
    if (error)
      return res
        .status(400)
        .json({ validationError: error.details[0].message });
  }
  try {
    if (await this.ifMailExist(req, Model))
      return res
        .status(400)
        .json(`Address mail : ${req.body.email} deJa existents`);
    const newUser = new Model({ ...req.body });
    newUser.password = this.hashPassword(req);
    if (await newUser.save()) {
      const token = this.createToken({
        id: newUser._id,
        role: newUser.role,
      });
      return res
        .status(200)
        .cookie('logToken', token, {
          httpOnly: true,
          maxAge: process.env.JWT_EXPIRATION_TIME,
        })
        .json({ role: newUser.role, isAuthenticated: true });
    }
  } catch (error) {
    res.status(500).json({ registerControllerError: error });
  }
};

exports.getAll = async (res, Model) => {
  try {
    const all = await Model.find();
    if (all) return res.status(200).json(all);
  } catch (err) {
    return res.status(400).json({ err });
  }
};
exports.deleteOne = async (req, res, Model) => {
  try {
    if (await Model.remove({ _id: req.params.id }).exec())
      return res.status(200).json({
        message: `Id ${req.params.id} deleted Successfully `,
      });
  } catch (err) {
    return res.status(500).json({ err });
  }
};
